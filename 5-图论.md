# 5-图论

---

## dijkstra

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll maxn = 10+1e5;
const ll inf = 0x3f3f3f3f;
typedef pair<ll,ll> pll;
    vector<pll> mp[100100];
    ll n,m,s;
    ll dis[100100];
    ll vis[100100];

void dij(ll s){
    for(ll i=1;i<=n;i++){
        dis[i]=inf;
    }
    dis[s]=0;
    priority_queue<pll,vector<pll>,greater<pll> > q;
    q.push({dis[s],s});
    while(!q.empty()){
        ll u=q.top().second;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(auto [w,v]:mp[u]){
            if(dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                q.push({dis[v],v});
            }
        }
    }
}
int main() {
	cin>>n>>m>>s;
	for(ll i=1;i<=m;i++){
    	ll u,v,w;
    	cin>>u>>v>>w;
    	mp[u].push_back({w,v});
	}
	dij(s);
	for(ll i=1;i<=n;i++)
        cout<<dis[i]<<" ";
    return 0;
}
```
## 并查集

```cpp
ll fa[maxn];
void init(ll n){
    for(ll i=1;i<=n;i++){
        fa[i]=i;
    }
}
ll find(ll x){
    if(fa[x]==x)
        return x;
    fa[x]=find(fa[x]);
    return fa[x];
}
void merge(ll x,ll y){
    if(find(x)==find(y)) return ;
    fa[find(x)]=find(y);
}
```
## 最小生成树

### prim O(n^2)

```cpp
    vector<pll> edge[maxn];
    ll dis[maxn];
    ll vis[maxn];
void update(ll u){
    for(auto [v,w]:edge[u]){
        dis[v]=min(dis[v],w);
    }
}
ll prim(ll n){
    for(ll i=1;i<=n;i++){
        vis[i]=0;
        dis[i]=inf;
    }
    vis[1]=1;
    update(1);
    ll ans=0;
    for(ll i=1;i<=n-1;i++){//连接n-1条边
        ll pos,mi=inf;
        for(ll j=1;j<=n;j++){
            if(vis[j]) continue;
            if(dis[j]<mi){
                mi=dis[j];
                pos=j;
            }
        }
        ans+=mi;
        vis[pos]=1;
        update(pos);    
    }
    return ans;
}
```

### prim O(mlogm) (小根堆优化)
```cpp
    vector<pll> edge[maxn];
    ll dis[maxn];
    ll vis[maxn];
ll prim(ll n){
    for(ll i=1;i<=n;i++){
        vis[i]=0;
        dis[i]=inf;
    }
    ll ans=0;
    priority_queue<pll,vector<pll>,greater<pll>> pq;
    pq.push({0,1});
    while(!pq.empty()){
        auto [d,u]=pq.top();
        pq.pop();
        if(vis[u]) continue;
        vis[u]=1;
        ans+=d;
        for(auto [v,w]:edge[u]){
            if(!vis[v]&&w<dis[v]){
                dis[v]=w;
                pq.push({dis[v],v});
            }
        }
    }
    return ans;
}
```

### kruskal

```cpp
typedef struct{
    ll u,v,w;
}eg;
    eg e[maxm];
    vector<pll> edge[maxn];
    ll fa[maxn];
bool cmp(eg a,eg b){
    return a.w<b.w;
}
ll find(ll a){
    return (fa[a]==a)?a:(fa[a]=find(fa[a]));
}
void merge(ll a,ll b){
    fa[a]=b;
}
ll kruscal(ll n,ll m){
    for(ll i=1;i<=n;i++){
        fa[i]=i;
    }
    sort(e+1,e+m+1,cmp);
    ll ans=0;
    for(ll i=1;i<=m;i++){
        ll a=find(e[i].u);
        ll b=find(e[i].v);
        if(a!=b){
            merge(a,b);
            ans+=e[i].w;
            n--;
        }
    }
    if(n==1){
        return ans;
    }else{
        return inf;
    }
}
for(ll i=1;i<=m;i++){
    ll u,v,w;
    cin>>u>>v>>w;
    edge[u].push_back({v,w});
    edge[v].push_back({u,w});
    e[i].u=u;e[i].v=v;e[i].w=w;
}
```

## LCA

```cpp
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false),cin.tie(nullptr), cout.tie(nullptr);
#define ll long long
#define ull unint long long
#define lowbit(i) ((i) & (-i))
#define ls(p) (p << 1)
#define rs(p) (p << 1 | 1)
#define rep(i, a, b) for (ll i = a; i <= b; i++)
#define per(i, a, b) for (ll i = a; i >= b; i--)

typedef pair<ll, ll> pll;
const ll mod = 1e9 + 7;
const ll inf = 0x3f3f3f3f;
const ll maxn = 5e5 + 200;

    ll n, q, root; 
    vector<ll> mp[N];
    ll lg2[maxn];
    ll dep[maxn];
    ll f[maxn][20];
    ll vis[maxn];
void dfs(ll u, ll fa = 0){
    if (vis[u]) return;
    vis[u] = 1;
    dep[u] = dep[fa] + 1;
    f[u][0] = fa;
    for (ll i = 1; i <= lg2[dep[u]]; i++){
        f[u][i] = f[f[u][i - 1]][i - 1];
    }
    for (auto v : mp[u]){
        dfs(v, u);
    }
}
ll lca(ll a, ll b){
    if (dep[a] > dep[b])
        swap(a, b);
    while (dep[a] != dep[b])
        b = f[b][lg2[dep[b] - dep[a]]];
    if (a == b)
        return a;
    for (ll k = lg2[dep[a]]; k >= 0; k--){
        if (f[a][k] != f[b][k]){
            a = f[a][k], b = f[b][k];
        }
    }
    return f[a][0];
}
int main(){
    IOS 
    cin >> n >> q >> root;
    for (ll i = 1; i < n; i++){
        ll u, v;
        cin >> u >> v;
        mp[u].push_back(v);
        mp[v].push_back(u);
    }
    for (ll i = 2; i <= n; i++){
        lg2[i] = lg2[i / 2] + 1;
    }
    dfs(root);
    while (q--){
        ll u, v;
        cin >> u >> v;
        cout << lca(u, v) << endl;
    }
    return 0;
}
```
