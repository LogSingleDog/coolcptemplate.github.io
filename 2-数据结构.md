# 2-数据结构


## 树状数组

```cpp
class BIT
{
    int n = 2e6;
    long long *a;

  public:
    BIT(int size) : n(size)
    {
        a = new long long[size + 10];
    }
    void update(int p, long long x)
    {
        while (p <= n)
            a[p] += x, p += (p & (-p));
    }

    long long query(int l, int r)
    {
        long long ret = 0;
        l--;
        while (r > 0)
            ret += a[r], r -= (r & (-r));
        while (l > 0)
            ret -= a[l], l -= (l & (-l));
        return ret;
    }
};

```
```cpp
template<typename T>
struct Fenwick{
    int n;
    vector<T> tr;
 
    Fenwick(int n) : n(n), tr(n + 1, 0){}
 
    int lowbit(int x){
        return x & -x;
    }
 
    void modify(int x, T c){//单点添加
        for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
    }
 
    void modify(int l, int r, T c){//区间添加
        modify(l, c);
        if (r + 1 <= n) modify(r + 1, -c);
    }
 
    T query(int x){
        T res = T();
        for(int i = x; i; i -= lowbit(i)) res += tr[i];
        return res;
    }
 
    T query(int l, int r){
        return query(r) - query(l - 1);
    }
 
    int find_first(T sum){//和出现的第一位置
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] < sum){
                ans |= 1 << i;
                val += tr[ans];
            }
        }
        return ans + 1;
    }
 
    int find_last(T sum){
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] <= sum){
                ans |= 1 << i;
                val += tr[ans];
            }
        }
        return ans;
    }
 
};
using BIT = Fenwick<int>; 
```


## 并查集

### 带有路径压缩的并查集

```cpp
struct DSU
{
    vector<int> f;

    DSU() {}
    DSU(int n)
    {
        clear(n);
    }

    // 多测时只构造一次 清空T次
    void clear(int n)
    {
        f.resize(n);
        iota(f.begin(), f.end(), 0);
    }

    int find(int x)
    {
        return f[x] == x ? x : (f[x] = find(f[x]));
    }

    bool same(int x, int y)
    {
        return find(x) == find(y);
    }

    bool merge(int x, int y)
    {
        x = find(x);
        y = find(y);
        return (x == y) ? false : f[y] = x;
    }
};
```

### 带权并查集

```cpp
struct DSU
{
    vector<int> f, siz;

    DSU() {}
    DSU(int n)
    {
        clear(n);
    }

    void clear(int n)
    {
        f.resize(n);
        iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }

    int find(int x)
    {
        return f[x] == x ? x : (f[x] = find(f[x]));
    }

    bool same(int x, int y)
    {
        return find(x) == find(y);
    }

    bool merge(int x, int y)
    {
        x = find(x);
        y = find(y);
        if (x == y)
            return false;
        // if (siz[x] < siz[y])
        //     swap(x, y);
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }

    int size(int x)
    {
        return siz[find(x)];
    }
};
```

## ST表

```cpp
// log2(x) 的预处理
// 1. 递推
lg[2] = 1;
for (int i = 3; i < N; i++)
    lg[i] = lg[i / 2] + 1;
// 2. 基于编译期计算
using std::array;
// WARNING: LOG_SIZE may cause CE if too big.
const int LOG_SIZE = 1e5 + 10;
constexpr array<int, LOG_SIZE> LOG = []() {
    array<int, LOG_SIZE> l{0, 0, 1};
    for (int i = 3; i < LOG_SIZE; i++)
        l[i] = l[i / 2] + 1;
    return l;
}();
// 3. 直接计算
int lg(int x)
{
    return 31 - __builtin_clz(x);
}
// STL 提供了 std::lg(), 底数是e.
```

```cpp
class SparseTable
{
  private:
    // SIZE depends on range of f[i][0].
    // 22 is suitable for 1e5.
    static const int SIZE = 22;
    // f[i][j] maintains the result from i to i + 2 ^ j - 1;
    int (*f)[SIZE];
    using func = std::function<int(int, int)>;
    func op;
    // length of f from 1 to l;
    int l;

  public:
    SparseTable(int a[][SIZE], func foo, int len) : f(a), op(foo), l(len)
    {
        for (int j = 1; j < SIZE; j++)
            for (int i = 1; i + (1 << j) - 1 <= len; i++)
                // f[i][j] comes from f[i][j - 1].
                // f[i][j - 1], f[i + 2^(j - 1)] cover the range of f[i][j].
                f[i][j] = foo(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
    };
    int query(int x, int y)
    {
        int s = LOG[y - x + 1];
        return op(f[x][s], f[y - (1 << s) + 1][s]);
    }
};
```

## 带懒标记线段树

```cpp
#include <vector>
using std::vector; 
class SegTree
{
  private:
    struct node
    {
        long long l, r, v, t;
    };
    int size = 1e6 + 5;
    vector<node> f;
    inline int ls(int p)
    {
        return p << 1;
    }
    inline int rs(int p)
    {
        return p << 1 | 1;
    }

    void build(int pos, int l, int r, vector<int> &a)
    {
        f[pos] = {l, r, 0, 0};
        if (l == r)
        {
            f[pos].v = a[l];
            return;
        }
        int mid = ((l + r) >> 1);
        build(ls(pos), l, mid, a);
        build(rs(pos), mid + 1, r, a);
        push_up(pos);
    }
    void push_up(int pos)
    {
        // modify here
        f[pos].v = f[ls(pos)].v + f[rs(pos)].v;
    }
    inline void push_down(long long pos)
    {
        if (!f[pos].t)
            return;
        f[ls(pos)].t += f[pos].t;
        f[rs(pos)].t += f[pos].t;
        int mid = (f[pos].l + f[pos].r) / 2;
        f[ls(pos)].v += f[pos].t * (mid - f[ls(pos)].l + 1); // modify here
        f[rs(pos)].v += f[pos].t * (f[rs(pos)].r - mid);     // modify here
        f[pos].t = 0;
    }

  public:
    SegTree(long long s, vector<int> &ori) : size(s)
    {
        f = vector<node>(s << 2);
        build(1, 1, s, ori);
    }
    long long query(int pos, int l, int r)
    {
        push_down(pos);
        if (f[pos].l >= l && f[pos].r <= r)
            return f[pos].v;
        int mid = (f[pos].l + f[pos].r) / 2;
        if (l > mid)
            return query(rs(pos), l, r);
        else if (r <= mid)
            return query(ls(pos), l, r);
        else
            // modify here
            return query(ls(pos), l, mid) + query(rs(pos), mid + 1, r);
    }
    void update(int pos, int l, int r, long long k)
    {
        if (f[pos].l >= l && f[pos].r <= r)
        {
            f[pos].t += k;
            f[pos].v += k * (r - l + 1);
            return;
        }
        push_down(pos);
        int mid = (f[pos].l + f[pos].r) / 2;
        if (l > mid)
            update(rs(pos), l, r, k);
        else if (r <= mid)
            update(ls(pos), l, r, k);
        else
            update(ls(pos), l, mid, k), update(rs(pos), mid + 1, r, k);
        push_up(pos);
    }
};

```

无懒标记

```cpp
class SegTree
{
  private:
    struct node
    {
        long long l, r, v;
    };
    int size = 1e6 + 5;
    vector<node> f;
    inline int ls(int p)
    {
        return p << 1;
    }
    inline int rs(int p)
    {
        return p << 1 | 1;
    }

    void build(int pos, int l, int r, vector<int> &a)
    {
        f[pos] = {l, r, 0};
        if (l == r)
        {
            f[pos].v = a[l];
            return;
        }
        int mid = ((l + r) >> 1);
        build(ls(pos), l, mid, a);
        build(rs(pos), mid + 1, r, a);
        push_up(pos);
    }
    void push_up(int pos)
    {
        // modify here
        f[pos].v = f[ls(pos)].v + f[rs(pos)].v;
    }

  public:
    SegTree(long long s, vector<int> &ori) : size(s)
    {
        f = vector<node>(s << 2);
        build(1, 1, s, ori);
    }
    long long query(int pos, int l, int r)
    {
        if (f[pos].l >= l && f[pos].r <= r)
            return f[pos].v;
        int mid = (f[pos].l + f[pos].r) / 2;
        if (l > mid)
            return query(rs(pos), l, r);
        else if (r <= mid)
            return query(ls(pos), l, r);
        else
            // modify here
            return query(ls(pos), l, mid) + query(rs(pos), mid + 1, r);
    }
    void update(int pos, int l, int r, long long k)
    {
        if (f[pos].l == l && f[pos].r == r)
        {
            f[pos].v += k;
            return;
        }
        int mid = (f[pos].l + f[pos].r) / 2;
        if (l > mid)
            update(rs(pos), l, r, k);
        else if (r <= mid)
            update(ls(pos), l, r, k);
        else
            update(ls(pos), l, mid, k), update(rs(pos), mid + 1, r, k);
        push_up(pos);
    }
};
```

zkw线段树

```cpp
class zkw_Segtree
{
    vector<int> tree;
    int N;
    void build(int n, vector<int> &a)
    {
        while (N <= n + 1)
            N <<= 1;
        tree = vector<int>(N << 1);
        for (int i = 1; i <= n; ++i)
            tree[i + N] = a[i];
        for (int i = N; i; --i)
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
    }
    void update(int x, int d)
    {
        for (int i = x + N; i; i >>= 1)
            tree[i] += d;
    }
    int query(int l, int r)
    {
        int ans = 0;
        for (l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1)
        {
            if (~l & 1)
                ans += tree[l ^ 1];
            if (r & 1)
                ans += tree[r ^ 1];
        }
        return ans;
    }
};
```

